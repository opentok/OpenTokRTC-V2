{"version":3,"sources":["web/js/roomStatus.js"],"names":["exports","_myCreationTime","_entries","_connectedAfterMe","otHelper","_connectedEarlierThanMe","cancelPendingSend","aConnectionId","conn","undefined","window","clearInterval","proccessNewConnection","evt","newUsrConnection","connection","creationTime","connectionId","isMyself","send","aNewUsrConnection","aUser","sendSignal","intervalResendStatus","setInterval","bind","_statusHandlers","signal:status","JSON","parse","data","this","removeListener","Utils","sendEvent","signal:statusACK","from","[object Object]","target","location","RoomStatus","set","key","value","get","init","aGlobalHandlers","aEntries","Array","isArray","push","addHandlers"],"mappings":"AAAC,CAACA,IAMA,IAGIC,EAHAC,EAAW,GAIf,MAAMC,EAAoB,GAC1B,IACIC,EADAC,EAA0B,EAO9B,SAASC,EAAkBC,GACzB,MAAMC,EAAOL,EAAkBI,QAClBE,IAATD,WACKL,EAAkBI,GACzBG,OAAOC,cAAcH,IAYzB,SAASI,EAAsBC,GAC7B,MAAMC,EAAmBD,EAAIE,WACvBC,EAAeF,EAAiBE,aAChCC,EAAeH,EAAiBG,aAEtC,GAAID,EAAef,EACjBI,SACK,IAAKD,EAASc,SAASJ,GAAmB,CAC/C,MAAMK,EAAOC,IAZjB,IAAoBC,EAHXhB,GAA2B,IAGhBgB,EAcDD,EAbVhB,EAASkB,WAAW,SAAUpB,EAAUmB,KAiB7CF,EAAKL,GAEL,MAAMS,EACJb,OAAOc,YAAYL,EAAKM,UAAKhB,EAAWK,GAlDnB,KAoDvBX,EAAkBc,GAAgBM,GAItC,MAAMG,EAAkB,CACtBC,gBAAiB,SAAUd,GACzBX,EAAW0B,KAAKC,MAAMhB,EAAIiB,OACZC,MA7CF3B,GAAUkB,WAAW,aAgDjCS,KAAKC,eAAe,iBACpBC,MAAMC,UAAU,+BAElBC,mBAAoB,SAAUtB,GAC5BP,EAAkBO,EAAIuB,KAAKnB,eAE7BoB,kBAAkBxB,GAKhBA,EAAIE,WAAWe,MAAQlB,EAAsBC,IAE/CwB,iBAAiBxB,GACfZ,EAAkBY,EAAIyB,OAAOvB,WAAWC,aACxCZ,EAAW2B,MAEbM,oBAAoBxB,GAKdA,EAAIE,WAAWC,aAAef,GAChCI,IAEFC,EAAkBO,EAAIE,WAAWE,eAEnCoB,sBACE3B,OAAO6B,SAAW,MA6BrBR,KAZOS,WAAa,CACnBC,IAAK,SAAaC,EAAKC,GACA,iBAAVA,IAGXzC,EAASwC,GAAOC,IAElBC,IAAIF,GACKxC,EAASwC,GAElBG,KAfF,SAAcC,EAAiBC,GAE7B,OADA7C,EAAW6C,GAAY,GATzB,SAAqBD,GAKnB,OAJKE,MAAMC,QAAQH,KACjBA,EAAkB,CAACA,IAErBA,EAAgBI,KAAKxB,GACdoB,EAKAK,CAAYL,MAzGtB","sourcesContent":["!(exports => {\n  const TIME_RESEND_STATUS = 60000;\n\n  // Persistent elements of the room\n  // Each elements should be key : Object\n  // where key is the name of a particular element to preserve\n  let _entries = {\n  };\n\n  let _myCreationTime;\n  const _connectedAfterMe = {};\n  let _connectedEarlierThanMe = 0;\n  let otHelper;\n\n  function sendStatusAck(aOTHelper) {\n    (aOTHelper || otHelper).sendSignal('statusACK');\n  }\n\n  function cancelPendingSend(aConnectionId) {\n    const conn = _connectedAfterMe[aConnectionId];\n    if (conn !== undefined) {\n      delete _connectedAfterMe[aConnectionId];\n      window.clearInterval(conn);\n    }\n  }\n\n  function iMustSend() {\n    return _connectedEarlierThanMe <= 0;\n  }\n\n  function sendStatus(aUser) {\n    return otHelper.sendSignal('status', _entries, aUser);\n  }\n\n  function proccessNewConnection(evt) {\n    const newUsrConnection = evt.connection;\n    const creationTime = newUsrConnection.creationTime;\n    const connectionId = newUsrConnection.connectionId;\n\n    if (creationTime < _myCreationTime) {\n      _connectedEarlierThanMe++;\n    } else if (!otHelper.isMyself(newUsrConnection)) {\n      const send = aNewUsrConnection => {\n        if (iMustSend()) {\n          sendStatus(aNewUsrConnection);\n        }\n      };\n\n      send(newUsrConnection);\n\n      const intervalResendStatus =\n        window.setInterval(send.bind(undefined, newUsrConnection),\n          TIME_RESEND_STATUS);\n      _connectedAfterMe[connectionId] = intervalResendStatus;\n    }\n  }\n\n  const _statusHandlers = {\n    'signal:status': function (evt) {\n      _entries = JSON.parse(evt.data);\n      sendStatusAck(this);\n      // FOLLOW-UP This event must have been an once event and don't need\n      // to remove it\n      this.removeListener('signal:status');\n      Utils.sendEvent('roomStatus:updatedRemotely');\n    },\n    'signal:statusACK': function (evt) {\n      cancelPendingSend(evt.from.connectionId);\n    },\n    connectionCreated(evt) {\n      // Dispatched when an new client (including your own) has connected to the\n      // session, and for every client in the session when you first connect\n      // Session object also dispatches a sessionConnected evt when your local\n      // client connects\n      evt.connection.data && proccessNewConnection(evt);\n    },\n    sessionConnected(evt) {\n      _myCreationTime = evt.target.connection.creationTime;\n      otHelper = this;\n    },\n    connectionDestroyed(evt) {\n      // If connection destroyed belongs to someone older than me,\n      // subtract one from connected early than me\n      // no matters who, it only care the number of them,\n      // when it's zero it's my turn to send history chat\n      if (evt.connection.creationTime < _myCreationTime) {\n        _connectedEarlierThanMe--;\n      }\n      cancelPendingSend(evt.connection.connectionId);\n    },\n    sessionDisconnected() {\n      window.location = '/';\n    }\n  };\n\n  function addHandlers(aGlobalHandlers) {\n    if (!Array.isArray(aGlobalHandlers)) {\n      aGlobalHandlers = [aGlobalHandlers];\n    }\n    aGlobalHandlers.push(_statusHandlers);\n    return aGlobalHandlers;\n  }\n\n  function init(aGlobalHandlers, aEntries) {\n    _entries = aEntries || {};\n    return addHandlers(aGlobalHandlers);\n  }\n\n  exports.RoomStatus = {\n    set: function set(key, value) {\n      if (typeof value !== 'object') {\n        return;\n      }\n      _entries[key] = value;\n    },\n    get(key) {\n      return _entries[key];\n    },\n    init\n  };\n})(this);\n"]}